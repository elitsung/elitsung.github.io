<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Step Tracker</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      margin: 0;
      line-height: 1.2;
      background-color: #fff;
      color: #111;
    }
    #main-content {
      max-width: 900px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem 1rem;
      box-sizing: border-box;
    }
    .metric {
      font-size: 1.2rem;
      margin: 0.5rem 0;
    }
    .week-subtitle {
      font-size: 0.9rem;
      color: #666;
      margin-top: 0.25rem;
    }
    .deficit {
      color: #dc3545;
    }
    .surplus {
      color: #28a745;
    }
    a {
      color: blue;
      text-decoration: underline;
    }
    #chart-container {
      margin: 3rem 0;
      width: 100%;
      max-width: 900px;
    }
    #year-metric {
      font-size: 2.0rem;
      font-weight: bold;
    }

    /* Comments Section */
    #comments-section {
      max-width: 700px;
      margin: 4rem auto 2rem;
      padding: 2rem;
      text-align: left;
      border-top: 1px solid rgba(0, 0, 0, 0.15);
    }
    #comments-section h2 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      font-weight: 500;
    }
    .comment-form {
      margin-bottom: 2rem;
      padding: 1.5rem;
      background-color: #f9f9f9;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    .comment-form input,
    .comment-form textarea {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.9rem;
      border: 1px solid rgba(0, 0, 0, 0.2);
      background-color: #fff;
      color: #111;
      box-sizing: border-box;
    }
    .comment-form input:focus,
    .comment-form textarea:focus {
      outline: 2px solid #111;
      outline-offset: -2px;
    }
    .comment-form textarea {
      min-height: 100px;
      resize: vertical;
    }
    .comment-form button {
      padding: 0.75rem 1.5rem;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.9rem;
      font-weight: 500;
      background-color: #111;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .comment-form button:hover {
      background-color: #333;
    }
    .comment-form button:disabled {
      background-color: #999;
      cursor: not-allowed;
    }
    .form-message {
      margin-top: 1rem;
      font-size: 0.9rem;
      padding: 0.5rem;
    }
    .form-message.success {
      color: #28a745;
      background-color: rgba(40, 167, 69, 0.1);
    }
    .form-message.error {
      color: #dc3545;
      background-color: rgba(220, 53, 69, 0.1);
    }
    .comments-list {
      margin-top: 2rem;
    }
    .comment {
      padding: 1rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    .comment:last-child {
      border-bottom: none;
    }
    .comment-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
    .comment-author {
      font-weight: 500;
      color: #111;
    }
    .comment-date {
      color: #666;
    }
    .comment-text {
      font-size: 0.95rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .loading {
      color: #666;
      font-style: italic;
    }
    .no-comments {
      color: #666;
      font-style: italic;
      padding: 1rem 0;
    }
    .comment-actions {
      margin-top: 0.5rem;
      font-size: 0.85rem;
    }
    .reply-btn {
      background: none;
      border: none;
      color: #0066cc;
      cursor: pointer;
      padding: 0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.85rem;
      text-decoration: underline;
    }
    .reply-btn:hover {
      color: #0052a3;
    }
    .comment-replies {
      margin-left: 2rem;
      margin-top: 1rem;
      padding-left: 1rem;
      border-left: 2px solid rgba(0, 0, 0, 0.1);
    }
    .comment.reply {
      padding: 0.75rem 0;
    }
    .replying-to {
      font-size: 0.85rem;
      color: #666;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      background-color: rgba(0, 102, 204, 0.05);
      border-left: 2px solid #0066cc;
    }
    .replying-to button {
      background: none;
      border: none;
      color: #dc3545;
      cursor: pointer;
      padding: 0;
      margin-left: 0.5rem;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.85rem;
      text-decoration: underline;
    }
    .replying-to button:hover {
      color: #a71d2a;
    }
  </style>
</head>
<body>
  <div id="main-content">
    <div class="metric" id="year-metric">Loading...</div>
    <div class="metric" id="month-metric">Loading...</div>
    <div class="metric" id="week-metric">Loading...</div>

    <div id="chart-container">
      <canvas id="steps-chart"></canvas>
    </div>
  </div>

  <!-- Comments Section -->
  <div id="comments-section">
    <h2>Comments</h2>

    <div class="comment-form">
      <div id="replying-indicator"></div>
      <input type="text" id="comment-name" placeholder="Your name" maxlength="50" required>
      <textarea id="comment-text" placeholder="Leave a comment..." maxlength="500" required></textarea>
      <button id="submit-comment">Post Comment</button>
      <div id="form-message"></div>
    </div>

    <div class="comments-list">
      <div id="comments-container" class="loading">Loading comments...</div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
    import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, where } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

    // Firebase configuration - YOU NEED TO REPLACE THIS WITH YOUR CONFIG
    const firebaseConfig = {
      apiKey: "AIzaSyCS47r_7TNhR1o_p5ULUPA3rxfVQtsKpH0",
      authDomain: "steps-tracker-comments.firebaseapp.com",
      projectId: "steps-tracker-comments",
      storageBucket: "steps-tracker-comments.firebasestorage.app",
      messagingSenderId: "764948316103",
      appId: "1:764948316103:web:ff254a4515714ba3c523e2",
      measurementId: "G-FMQ20TRJEF"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Reference to comments collection
    const commentsRef = collection(db, 'step-tracker-comments');

    // State for reply mode
    let replyingTo = null;

    // Load and display comments in real-time
    function loadComments() {
      const q = query(commentsRef, orderBy('timestamp', 'desc'));

      onSnapshot(q, (snapshot) => {
        const commentsContainer = document.getElementById('comments-container');

        if (snapshot.empty) {
          commentsContainer.innerHTML = '<div class="no-comments">No comments yet. Be the first to comment!</div>';
          commentsContainer.classList.remove('loading');
          return;
        }

        commentsContainer.innerHTML = '';
        commentsContainer.classList.remove('loading');

        // Organize comments into parent-child structure
        const allComments = [];
        snapshot.forEach((doc) => {
          allComments.push({
            id: doc.id,
            ...doc.data()
          });
        });

        // Build a map of all comments by ID for quick lookup
        const commentsById = {};
        allComments.forEach(comment => {
          commentsById[comment.id] = comment;
        });

        // Build a map of replies by parentId
        const repliesMap = {};
        allComments.forEach(comment => {
          if (comment.parentId) {
            if (!repliesMap[comment.parentId]) {
              repliesMap[comment.parentId] = [];
            }
            repliesMap[comment.parentId].push(comment);
          }
        });

        // Sort replies by timestamp (oldest first for replies)
        Object.keys(repliesMap).forEach(parentId => {
          repliesMap[parentId].sort((a, b) => {
            if (!a.timestamp || !b.timestamp) return 0;
            return a.timestamp.toMillis() - b.timestamp.toMillis();
          });
        });

        // Get top-level comments (no parentId)
        const parentComments = allComments.filter(c => !c.parentId);

        // Render parent comments with all nested replies recursively
        parentComments.forEach((comment) => {
          const commentEl = renderCommentWithReplies(comment, repliesMap, false);
          commentsContainer.appendChild(commentEl);
        });
      }, (error) => {
        console.error('Error loading comments:', error);
        document.getElementById('comments-container').innerHTML =
          '<div class="error">Error loading comments. Please refresh the page.</div>';
      });
    }

    // Recursively render a comment and all its nested replies
    function renderCommentWithReplies(comment, repliesMap, isReply) {
      const commentEl = createCommentElement(comment, isReply);

      // Get direct replies to this comment
      const replies = repliesMap[comment.id] || [];

      if (replies.length > 0) {
        const repliesContainer = document.createElement('div');
        repliesContainer.className = 'comment-replies';

        // Recursively render each reply and its nested replies
        replies.forEach(reply => {
          const replyEl = renderCommentWithReplies(reply, repliesMap, true);
          repliesContainer.appendChild(replyEl);
        });

        commentEl.appendChild(repliesContainer);
      }

      return commentEl;
    }

    // Create comment HTML element
    function createCommentElement(comment, isReply = false) {
      const div = document.createElement('div');
      div.className = isReply ? 'comment reply' : 'comment';

      const date = comment.timestamp ?
        new Date(comment.timestamp.toDate()).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        }) : 'Just now';

      div.innerHTML = `
        <div class="comment-header">
          <span class="comment-author">${escapeHtml(comment.name)}</span>
          <span class="comment-date">${date}</span>
        </div>
        <div class="comment-text">${escapeHtml(comment.text)}</div>
        <div class="comment-actions">
          <button class="reply-btn" data-comment-id="${comment.id}" data-comment-author="${escapeHtml(comment.name)}">Reply</button>
        </div>
      `;

      // Add reply button event listener
      const replyBtn = div.querySelector('.reply-btn');
      replyBtn.addEventListener('click', () => {
        startReply(comment.id, comment.name);
      });

      return div;
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Start reply mode
    function startReply(commentId, authorName) {
      replyingTo = { id: commentId, name: authorName };

      const indicator = document.getElementById('replying-indicator');
      indicator.className = 'replying-to';
      indicator.innerHTML = `Replying to <strong>${escapeHtml(authorName)}</strong> <button id="cancel-reply">Cancel</button>`;

      // Focus on the text input
      document.getElementById('comment-text').focus();

      // Add cancel button listener
      document.getElementById('cancel-reply').addEventListener('click', cancelReply);
    }

    // Cancel reply mode
    function cancelReply() {
      replyingTo = null;
      const indicator = document.getElementById('replying-indicator');
      indicator.className = '';
      indicator.innerHTML = '';
    }

    // Submit comment
    document.getElementById('submit-comment').addEventListener('click', async () => {
      const nameInput = document.getElementById('comment-name');
      const textInput = document.getElementById('comment-text');
      const submitBtn = document.getElementById('submit-comment');
      const messageDiv = document.getElementById('form-message');

      const name = nameInput.value.trim();
      const text = textInput.value.trim();

      // Validation
      if (!name || !text) {
        showMessage('Please fill in both name and comment.', 'error');
        return;
      }

      if (name.length > 50) {
        showMessage('Name must be 50 characters or less.', 'error');
        return;
      }

      if (text.length > 500) {
        showMessage('Comment must be 500 characters or less.', 'error');
        return;
      }

      // Disable button while submitting
      submitBtn.disabled = true;
      messageDiv.textContent = '';

      try {
        const commentData = {
          name: name,
          text: text,
          timestamp: serverTimestamp(),
          parentId: replyingTo ? replyingTo.id : null
        };

        await addDoc(commentsRef, commentData);

        // Clear form
        nameInput.value = '';
        textInput.value = '';
        cancelReply(); // Clear reply mode
        showMessage('Comment posted successfully!', 'success');
      } catch (error) {
        console.error('Error posting comment:', error);
        showMessage('Error posting comment. Please try again.', 'error');
      } finally {
        submitBtn.disabled = false;
      }
    });

    // Show form message
    function showMessage(text, type) {
      const messageDiv = document.getElementById('form-message');
      messageDiv.textContent = text;
      messageDiv.className = `form-message ${type}`;

      if (type === 'success') {
        setTimeout(() => {
          messageDiv.textContent = '';
          messageDiv.className = 'form-message';
        }, 3000);
      }
    }

    // Allow Enter key in textarea (but Ctrl+Enter submits)
    document.getElementById('comment-text').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.ctrlKey) {
        document.getElementById('submit-comment').click();
      }
    });

    // Load comments when page loads
    loadComments();
  </script>

  <script>
    const DAILY_GOAL = 10000;

    async function loadStepData() {
      try {
        const response = await fetch('steps_data.csv');
        const text = await response.text();
        const lines = text.trim().split('\n');

        // Parse CSV (skip header)
        const data = lines.slice(1).map(line => {
          const [date, steps] = line.split(',');
          // Parse date as local time to avoid timezone issues
          const [year, month, day] = date.split('-').map(Number);
          return {
            date: new Date(year, month - 1, day),
            steps: parseInt(steps)
          };
        }).filter(entry => !isNaN(entry.steps));

        calculateDeficits(data);
        createCumulativeChart(data);
      } catch (error) {
        console.error('Error loading step data:', error);
        document.getElementById('year-metric').textContent = 'Error loading data';
        document.getElementById('month-metric').textContent = '';
        document.getElementById('week-metric').textContent = '';
      }
    }

    function calculateDeficits(data) {
      const now = new Date();
      const yearStart = new Date(now.getFullYear(), 0, 1);
      const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);

      // Get start of week (Sunday)
      const weekStart = new Date(now);
      weekStart.setDate(now.getDate() - now.getDay());
      weekStart.setHours(0, 0, 0, 0);

      // Filter data by period
      const yearData = data.filter(d => d.date >= yearStart && d.date <= now);
      const monthData = data.filter(d => d.date >= monthStart && d.date <= now);
      const weekData = data.filter(d => d.date >= weekStart && d.date <= now);

      // Count actual days with data (not calendar days elapsed)
      const daysInYear = yearData.length;
      const daysInMonth = monthData.length;
      const daysInWeek = weekData.length;

      // Calculate totals
      const yearSteps = yearData.reduce((sum, d) => sum + d.steps, 0);
      const monthSteps = monthData.reduce((sum, d) => sum + d.steps, 0);
      const weekSteps = weekData.reduce((sum, d) => sum + d.steps, 0);

      // Calculate deficits (negative means deficit, positive means surplus)
      const yearDeficit = yearSteps - (DAILY_GOAL * daysInYear);
      const monthDeficit = monthSteps - (DAILY_GOAL * daysInMonth);
      const weekDeficit = weekSteps - (DAILY_GOAL * daysInWeek);

      // Get month name for display
      const monthName = now.toLocaleDateString('en-US', { month: 'long' });

      // Get week date range for subtitle
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      const weekRange = `${weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${weekEnd.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;

      // Display results
      displayMetric('year-metric', 'Step Deficit in 2026', yearDeficit);
      displayMetric('month-metric', `Deficit in ${monthName}`, monthDeficit);
      displayMetric('week-metric', 'Deficit This Week', weekDeficit, weekRange);
    }

    function displayMetric(elementId, label, value, subtitle = null) {
      const element = document.getElementById(elementId);
      const isDeficit = value < 0;
      const absValue = Math.abs(value).toLocaleString();
      const status = isDeficit ? 'Deficit' : 'Surplus';
      const className = isDeficit ? 'deficit' : 'surplus';

      let html = `<span class="${className}">${label.replace('Deficit', status)}: ${absValue}</span>`;
      if (subtitle) {
        html += `<div class="week-subtitle">${subtitle}</div>`;
      }

      element.innerHTML = html;
    }

    function createCumulativeChart(data) {
      // Sort data by date
      const sortedData = [...data].sort((a, b) => a.date - b.date);

      if (sortedData.length === 0) return;

      const startDate = sortedData[0].date;
      const labels = [];
      const fullDateLabels = []; // Store full date labels for tooltip
      const actualCumulative = [];
      const benchmarkCumulative = [];
      const dailySteps = []; // Store daily steps for tooltip only

      let cumulativeSteps = 0;

      // Calculate cumulative values
      sortedData.forEach((entry, index) => {
        cumulativeSteps += entry.steps;
        const dayNumber = index + 1;

        const shortLabel = entry.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        labels.push(shortLabel);
        // Format as "Jan. 28" for tooltip
        const monthAbbr = entry.date.toLocaleDateString('en-US', { month: 'short' });
        const day = entry.date.getDate();
        fullDateLabels.push(`Steps on ${monthAbbr} ${day}`);
        actualCumulative.push(cumulativeSteps);
        benchmarkCumulative.push(DAILY_GOAL * dayNumber);
        dailySteps.push(entry.steps); // Store daily steps
      });

      const ctx = document.getElementById('steps-chart').getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Actual Cumulative Steps',
              data: actualCumulative,
              borderColor: '#111',
              backgroundColor: 'rgba(17, 17, 17, 0.1)',
              borderWidth: 2,
              tension: 0.1,
              fill: false
            },
            {
              label: '10,000 Steps/Day Benchmark',
              data: benchmarkCumulative,
              borderColor: '#dc3545',
              backgroundColor: 'rgba(220, 53, 69, 0.1)',
              borderWidth: 2,
              borderDash: [5, 5],
              tension: 0.1,
              fill: false
            },
            {
              label: 'Daily Steps',
              data: dailySteps,
              borderColor: 'rgba(0, 0, 0, 0)', // Transparent
              backgroundColor: 'rgba(0, 0, 0, 0)', // Transparent
              borderWidth: 0,
              pointRadius: 0,
              pointHoverRadius: 0,
              tension: 0.1,
              fill: false,
              hidden: false, // Keep it active for tooltip but invisible
              yAxisID: 'y1' // Use separate hidden y-axis
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: {
                  family: '"IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'
                }
              }
            },
            title: {
              display: true,
              text: 'Cumulative Steps Over Time',
              font: {
                family: '"IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace',
                size: 16
              }
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  // Get the formatted date label
                  const index = context[0].dataIndex;
                  return fullDateLabels[index];
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                },
                font: {
                  family: '"IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'
                }
              }
            },
            y1: {
              display: false, // Hidden axis for daily steps
              beginAtZero: true
            },
            x: {
              ticks: {
                maxRotation: 45,
                minRotation: 45,
                font: {
                  family: '"IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'
                }
              }
            }
          }
        }
      });
    }

    // Load data on page load
    loadStepData();
  </script>
</body>
</html>
